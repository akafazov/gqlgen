{{ reserveImport .ClientModelPath }}

import (
	"context"
	"fmt"
	"reflect"

	"{{ .ClientModelPath }}"
	libmodel "github.com/darashevcstbg/gqlgen/graph/model"
	"github.com/darashevcstbg/gqlgen/pkg/meetups"
)

// CreateMeetup is the resolver for the createMeetup field.
func (r *mutationResolver) CreateMeetup(ctx context.Context, input model.NewMeetup) (*model.Meetup, error) {
	// convert input
	var m libmodel.NewMeetup
	err := copyStruct(&m, &input)
	if err != nil {
		return nil, err
	}

	// call library
	newmeetup, err := meetups.CreateMeetup(m)
	if err != nil {
		return nil, err
	}

	// convert output
	meetup := &model.Meetup{}
	err = copyStruct(meetup, newmeetup)
	if err != nil {
		return nil, err
	}

	return meetup, nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.NewUser) (*model.User, error) {
	// convert input
	var u libmodel.NewUser
	err := copyStruct(&u, &input)
	if err != nil {
		return nil, err
	}

	// call library
	newuser, err := meetups.CreateUser(u)
	if err != nil {
		return nil, err
	}

	// convert output
	user := &model.User{}
	err = copyStruct(user, newuser)
	if err != nil {
		return nil, err
	}

	return user, nil
}

// Meetups is the resolver for the meetups field.
func (r *queryResolver) Meetups(ctx context.Context) ([]*model.Meetup, error) {
	println("-- query: meetups")
	ms, err := meetups.GetMeetups(ctx)
	if err != nil {
		return nil, err
	}

	meetups := make([]*model.Meetup, len(ms))
	for i, m := range ms {
		meetup := &model.Meetup{}
		err := copyStruct(meetup, m)
		if err != nil {
			return nil, err
		}
		meetups[i] = meetup
	}

	return meetups, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	us, err := meetups.GetUsers(ctx)
	if err != nil {
		return nil, err
	}

	users := make([]*model.User, len(us))
	for i, u := range us {
		user := &model.User{}
		err := copyStruct(user, u)
		if err != nil {
			return nil, err
		}
		users[i] = user
	}

	return users, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

func copyStruct(dest, src interface{}) error {
	destVal := reflect.ValueOf(dest).Elem()
	srcVal := reflect.ValueOf(src).Elem()

	if destVal.Type() != srcVal.Type() {
		return fmt.Errorf("type mismatch: %s != %s", destVal.Type(), srcVal.Type())
	}

	for i := 0; i < destVal.NumField(); i++ {
		destVal.Field(i).Set(srcVal.Field(i))
	}

	return nil
}
